<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<script>
    //使用定时器，即开启了异步操作  代码执行时会优先执行定时器后面的代码，一秒后开启异步执行定时器
    // setTimeout(() => {
    //     console.log('Hello Promise');
    // },1000)

    //Promise的参数即为函数,函数本身有两个参数（resolve,reject）
    //resolve,reject本身也是函数    !!!!!!*****链式编程*****！！！！！
    new Promise((resolve,reject) => {

        //第一次网络请求的代码
        setTimeout(() => {
        resolve()
    },1000)
    }).then(() => {
        //第一次拿到结果的处理代码
        console.log('Hello Promise');
        console.log('Hello Promise');
        console.log('Hello Promise');

        return new Promise((resolve,reject) => {
            //第二次网络请求的代码
            setTimeout(() => {
            resolve()
        },1000)
        })
    }).then(() => {
        //第二次处理的结果
        console.log('Hello world');
        console.log('Hello world');
        console.log('Hello world');
    })

    //什么情况下使用Promise   一般情况下有异步操作时，利用Promise对此异步操作进行封装
    //new -> 构造函数(1.保存了一些状态信息 2.执行传入的参数)
    //执行传入的回调函数时，传入resolve和reject两个参数，两个参数都是函数
    new Promise ((resolve,reject) => {
        setTimeout(() => {
            //成功的调用resolve
                    // resolve ('Hello World')

                    //失败的调用reject
                    reject('error message')
                    // console.log('Hello Promise');  //假设有100多行的代码
                    },1000)
                }).then((data) => {
                    console.log('data');
                    console.log('data');
                    console.log('data');
                }).catch((err) => {
                    console.log(err)
                })


</script>
<body>
    
</body>
</html>